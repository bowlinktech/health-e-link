/** 02.11.2014 **/

drop procedure `universaltranslator`.`runMacro`;


/** 02122014 Grace **/

INSERT INTO `universalTranslator`.`lu_ErrorCodes` (`displayText`, `description`, `status`) 
VALUES ('System Error', 'System Error, could be from crosswalks or macros', 1);

DELIMITER $$
CREATE Procedure `universaltranslator`.`setInboundOutBoundTables`(in foroutboundProcessing boolean) 
proc_main:begin

-- this SP sets the inbound / outbound tables
set @translatedTable = "transactionTranslatedIn";
set @transactionTable = "transactionIn";
set @batchTable = "batchUploads";
set @batchIdType = "batchId";
set @errorTable = "transactionInErrors";

if (foroutboundProcessing) THEN
BEGIN -- true
		set @translatedTable = "transactionTranslatedOut";
		set @transactionTable = "transactionTarget";
		set @batchTable = "batchDowloads";
		set @batchIdType = "batchDLId";
		set @errorTable = "transactionOutErrors";
END; 
END IF;

end proc_main$$
DELIMITER ;

/** 02132014 Grace **/
ALTER TABLE `universalTranslator`.`Macro_Names` 
CHANGE COLUMN `Category` `Category` VARCHAR(50) CHARACTER SET 'utf8' NULL DEFAULT 'Stored Procedure' ;

delete from `Macro_Names`;
INSERT INTO `Macro_Names` VALUES (1,'Stored Procedure','MatchFieldAUpdateFieldB','IF SFA = CON1, TFB = CON2',1,NULL,'MatchFieldAUpdateFieldB','','Please enter field number for matching','Please enter field number to update','Please enter the constant to match','Please enter the constant for update');

DELIMITER $$
CREATE Procedure `universaltranslator`.`MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int) 
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId,");");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId,");");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

/** grace 021314 **/
INSERT INTO `universalTranslator`.`macro_names` (`Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`) VALUES ('MatchFAUpdateSF', 'IF SFA = CON1, SF = CON2', 'MatchFAUpdateSF', 'Please enter field number to match', 'Please enter constant to match', 'Please enter constanct to update to');

/** Chad 2.13.14 @ 11:11 AM **/
ALTER TABLE `universalTranslator`.`BatchDownloads` 
ADD COLUMN `lastDownloaded` DATETIME NULL AFTER `mergeable`;

/** Chad 2.13.14 @ 11:09 PM **/
ALTER TABLE `universalTranslator`.`rel_TransportFTPDetails` 
ADD COLUMN `port` VARCHAR(45) NULL AFTER `method`;


/** Chad 2.14.14 @ 11:41 AM **/
CREATE TABLE `universaltranslator`.`targetoutputrunlogs` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `configId` INT NOT NULL,
  `lastRunTime` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`));

/** Chad 2.18.14 @ 11:51 AM **/
ALTER TABLE `universalTranslator`.`message_ToProvider` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_ToOrg` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_PatientAddresses` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL COMMENT 'State - e.g. MA' ;

ALTER TABLE `universalTranslator`.`message_FromProvider` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_FromOrg` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;


/** 02.18.2014 **/
ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `required` BIT NULL AFTER `configurationFormFieldsId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `required` BIT NULL AFTER `configurationFormFieldsId`;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `stackTrace` TEXT NULL AFTER `validationTypeId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `stackTrace` TEXT NULL AFTER `validationTypeId`;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `transactionInId` `transactionInId` INT(11) NULL ;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
CHANGE COLUMN `transactionTargetId` `transactionInId` INT(11) NULL ;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `configId` INT NULL AFTER `batchUploadId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
CHANGE COLUMN `transactionInId` `transactionTargetId` INT(11) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `configId` INT NULL AFTER `transactionTargetId`;

/** 02.19.14 Grace **/
ALTER TABLE `universalTranslator`.`transactionInErrors` 
DROP FOREIGN KEY `configFFFKId`;
ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `configurationFormFieldsId` `configurationFormFieldsId` INT(11) NULL ;
ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD CONSTRAINT `configFFFKId`
  FOREIGN KEY (`configurationFormFieldsId`)
  REFERENCES `universalTranslator`.`configurationFormFields` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `dateCreated` `dateCreated` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ;


/** Grace 02.19.14 **/
ALTER TABLE `universalTranslator`.`rel_crosswalkData` 
CHANGE COLUMN `targetValue` `targetValue` VARCHAR(45) NOT NULL ;


/** Chad 2.20.14 @ 11:26 AM **/
CREATE TABLE `universalTranslator`.`configurationHL7Details` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `configId` INT NOT NULL,
  `fieldSeparator` VARCHAR(1) NOT NULL DEFAULT '|',
  `componentSeparator` VARCHAR(1) NOT NULL DEFAULT '^',
  `EscapeChar` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `hl7ConfigIdfk_idx` (`configId` ASC),
  CONSTRAINT `hl7ConfigIdfk`
    FOREIGN KEY (`configId`)
    REFERENCES `universalTranslator`.`configurations` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

CREATE TABLE `universalTranslator`.`configurationHL7Segments` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `hl7Id` INT NOT NULL,
  `segmentName` VARCHAR(3) NOT NULL,
  `displayPos` INT NOT NULL DEFAULT 1,
  PRIMARY KEY (`id`));

ALTER TABLE `universalTranslator`.`configurationHL7Segments` 
ADD INDEX `segHL7Idfk_idx` (`hl7Id` ASC);
ALTER TABLE `universalTranslator`.`configurationHL7Segments` 
ADD CONSTRAINT `segHL7Idfk`
  FOREIGN KEY (`hl7Id`)
  REFERENCES `universalTranslator`.`configurationHL7Details` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

CREATE TABLE `universalTranslator`.`configurationHL7Elements` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `hl7Id` INT NOT NULL,
  `segmentId` INT NOT NULL,
  `elementName` VARCHAR(255) NOT NULL,
  `defaultValue` VARCHAR(45) NULL DEFAULT 'null',
  `fieldDescriptor` VARCHAR(255) NULL,
  `fieldValue` VARCHAR(4) NULL DEFAULT 'null',
  `displayPos` INT NOT NULL DEFAULT 1,
  PRIMARY KEY (`id`));

ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD INDEX `elemHLyIdfk_idx` (`hl7Id` ASC),
ADD INDEX `elemSegIdfk_idx` (`segmentId` ASC);
ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD CONSTRAINT `elemHLyIdfk`
  FOREIGN KEY (`hl7Id`)
  REFERENCES `universalTranslator`.`configurationHL7Details` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION,
ADD CONSTRAINT `elemSegIdfk`
  FOREIGN KEY (`segmentId`)
  REFERENCES `universalTranslator`.`configurationHL7Segments` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;


/** Chad 2.21.14 @ 3:13 PM **/
ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
DROP COLUMN `fieldValue`,
DROP COLUMN `fieldDescriptor`,
DROP COLUMN `defaultValue`;

CREATE TABLE `universalTranslator`.`configurationHL7ElementValues` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `elementId` INT NOT NULL,
  `defaultValue` VARCHAR(45) NULL DEFAULT NULL,
  `fieldDescriptor` VARCHAR(255) NULL DEFAULT NULL,
  `fieldValue` VARCHAR(4) NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `elemValIdfk_idx` (`elementId` ASC),
  CONSTRAINT `elemValIdfk`
    FOREIGN KEY (`elementId`)
    REFERENCES `universalTranslator`.`configurationHL7Elements` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

ALTER TABLE `universalTranslator`.`configurationHL7ElementValues` 
ADD COLUMN `displayPos` INT NULL DEFAULT 1 AFTER `fieldValue`;

ALTER TABLE `universalTranslator`.`configurationHL7ElementValues` 
DROP COLUMN `defaultValue`;

ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD COLUMN `defaultValue` VARCHAR(45) NULL AFTER `displayPos`;

  
  /** grace 022114 **/
  drop procedure insertValidationErrors;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in cffId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[a-z0-9\._%+!$&*=^|~#%\'`?{}/\-]+@[a-z0-9\.-]+\.[a-z]{2,6}$ or ^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, cffId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;
 
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, configurationFormFieldsId, errorid, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',cffId,',2, ', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId != 12);');

PREPARE stmt from @stmt;
EXECUTE stmt;

 END$$
DELIMITER ;


drop procedure MatchFieldAUpdateFieldB;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

/** grace 02242014 **/
drop procedure insertValidationErrors;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in cffId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, cffId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;
 
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, configurationFormFieldsId, errorid, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',cffId,',2, ', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId != 12);');

PREPARE stmt from @stmt;
EXECUTE stmt;

 END$$
DELIMITER ;

/** 02242014 Grace **/
ALTER TABLE `universalTranslator`.`transactionIn` 
ADD COLUMN `loadTableId` VARCHAR(45) NULL AFTER `transactionTargetId`;

ALTER TABLE `universalTranslator`.`transactionInRecords` 
ADD COLUMN `loadTableId` VARCHAR(45) NULL AFTER `dateCreated`;

/** 02252014 Grace **/
CREATE TABLE `universalTranslator`.`batchUploadConfirgurations` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `batchId` INT NOT NULL,
  `configId` INT NULL,
  `dateCreated` DATETIME NOT NULL DEFAULT current_timestamp,
  PRIMARY KEY (`id`));

ALTER TABLE `universalTranslator`.`batchUploadConfirgurations` 
ADD INDEX `bucBatchIdFK_idx` (`batchId` ASC);
ALTER TABLE `universalTranslator`.`batchUploadConfirgurations` 
ADD CONSTRAINT `bucBatchIdFK`
  FOREIGN KEY (`batchId`)
  REFERENCES `universalTranslator`.`batchUploads` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

/** 02262014 **/
DROP TABLE `universalTranslator`.`batchUploadConfirgurations`;

ALTER TABLE `universalTranslator`.`batchUploads` 
ADD COLUMN `containsHeaderRow` BIT NULL AFTER `errorRecordCount`,
ADD COLUMN `delimChar` VARCHAR(1) NULL AFTER `containsHeaderRow`,
ADD COLUMN `fileLocation` VARCHAR(255) NULL AFTER `delimChar`;

/** 02262014 Grace 10:35PM **/
ALTER TABLE `universalTranslator`.`batchUploads` 
ADD COLUMN `configId` INT NULL COMMENT 'configuration for message type if selected' AFTER `fileLocation`;

/** 02262014 Grace 10:57PM **/
update batchuploads set containsHeaderRow = 0;

ALTER TABLE `universalTranslator`.`configurationMessageSpecs` 
CHANGE COLUMN `containsHeaderRow` `containsHeaderRow` BIT(1) NOT NULL DEFAULT b'0' ;

/** Chad 2-26-2014 @ 1:55 PM **/
ALTER TABLE `universalTranslator`.`configurationTransportDetails` 
ADD COLUMN `fileExt` VARCHAR(4) NULL DEFAULT NULL AFTER `copiedTransportId`;

/** Chad 2-27-2014 @ 4:23 PM **/
INSERT INTO `universalTranslator`.`lu_ProcessStatus` (`category`, `displayCode`, `displayText`, `status`) VALUES ('transaction', 'CNL', 'Canceled', 1);
INSERT INTO `universalTranslator`.`lu_ProcessStatus` (`category`, `displayCode`, `displayText`, `status`) VALUES ('batch', 'SCN', 'Submission Canceled', 1);

/** Chad 3-3-2014 @ 11:26 AM **/
ALTER TABLE `universalTranslator`.`rel_TransportFTPDetails` 
CHANGE COLUMN `port` `port` INT NULL DEFAULT 0 ;

/** grace 03-03-2014 09:53PM **/
DELETE FROM `universalTranslator`.`macro_names` WHERE `ID`='68';
UPDATE `universalTranslator`.`macro_names` SET `ID`='2' WHERE `ID`='67';

INSERT INTO `universalTranslator`.`macro_names` (`Category`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`) VALUES ('Date Manipulation', 'yyyymmddTommddyyyy', 'YYYY-MM-DD to MM-DD-YYYY', 'yyyymmddTommddyyyy', 'Please enter the field # to set source field date to', 'Please enter date part separator.  e.g. -, ., /');
UPDATE `universalTranslator`.`macro_names` SET `Category`='String Match' WHERE `ID`='1';
UPDATE `universalTranslator`.`macro_names` SET `Category`='String Match' WHERE `ID`='2';

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- we build sql here 
set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
concat(substring(",srcField, ", 6,2), '",con1, "',  
substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
where id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;

end proc_main$$
DELIMITER ;


/**  Grace 03042014 12:20PM **/
drop procedure yyyymmddTommddyyyy;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
concat(substring(",srcField, ", 6,2), '",con1, "',  
substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;


/** Chad 3-04-14 @ 1:19 PM **/
ALTER TABLE `universalTranslator`.`rel_TransportFTPDetails` 
ADD COLUMN `protocol` VARCHAR(45) NULL DEFAULT 'FTP' AFTER `port`;

/** Grace 03042014 08:49PM **/
ALTER TABLE `universalTranslator`.`transactionTranslatedIn` 
ADD UNIQUE INDEX `transactionInId_UNIQUE` (`transactionInId` ASC);

ALTER TABLE `universalTranslator`.`transactionTranslatedOut` 
ADD UNIQUE INDEX `transactionTargetId_UNIQUE` (`transactionTargetId` ASC);

ALTER TABLE `universalTranslator`.`transactionOutRecords` 
ADD UNIQUE INDEX `transactionTargetId_UNIQUE` (`transactionTargetId` ASC);

ALTER TABLE `universalTranslator`.`transactionInRecords` 
ADD UNIQUE INDEX `transactionInId_UNIQUE` (`transactionInId` ASC);

INSERT INTO `universaltranslator`.`lu_ProcessStatus` (`category`, `displayCode`, `displayText`) VALUES ('transaction', 'PE', 'Processing Error');

ALTER TABLE `universalTranslator`.`transactionTarget` 
CHANGE COLUMN `batchDLId` `batchDLId` INT(11) NULL DEFAULT 0 ;

/** Chad 3-06-2014 @ 10:14 AM **/
ALTER TABLE `universalTranslator`.`message_VisitInfo` 
ADD COLUMN `originalReferralId` VARCHAR(45) NULL DEFAULT NULL AFTER `totalTimesSeen`;

/** Grace 3.10.14 **/
INSERT INTO `universalTranslator`.`lu_ErrorCodes` (`displayText`, `description`) VALUES ('Invalid Configuration', 'Transaction does not match a valid configuration');

CREATE TABLE `uploadBatchRunlogs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `batchId` int(11) NOT NULL,
  `statusId` int(11) NOT NULL,
  `logTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=138 DEFAULT CHARSET=latin1;

USE `universalTranslator`;
DELIMITER $$

CREATE DEFINER=`root`@`localhost` trigger uploadRunLogs after update on batchUploads
for each row
begin
  insert into uploadBatchRunlogs (statusId, batchId) 
values (new.statusId, new.id);
end $$
DELIMITER ;


INSERT INTO `universaltranslator`.`lu_ErrorCodes` (`displayText`, `description`) VALUES ('No Transactions Found', 'No Transactions were found for batch');

/** grace 03102014 11:02AM **/
ALTER TABLE `universalTranslator`.`transactionIn` 
ADD INDEX `batchAndIdIdx` (`id` ASC, `batchId` ASC);

/** grace 03102014 12:41 PM  **/
ALTER TABLE `universalTranslator`.`transactionInRecords` 
ADD INDEX `loadTableId` (`loadTableId` ASC);

/** grace 03102014 16:33 **/
INSERT INTO `universalTranslator`.`lu_ErrorCodes` (`displayText`, `description`) VALUES ('Batch Handling Error', 'Multiple batch handling found');

/** grace 03102014 16:53 **/
INSERT INTO `universaltranslator`.`macro_names` (`Category`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`) VALUES ('Date Manipulation', 'mmddyyyyToyyyymmdd', 'mm-dd-yyyyToyyyy-mm-dd', 'mmddyyyyToyyyymmdd', 'Please enter the field # to set source field date to', 'Please enter date part separator.  e.g. -, ., /');

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
concat(substring(",srcField, ", 7,4), '",con1, "',  
substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

/** gc 03122014 11:33AM **/
update lu_errorCodes set id = 1 where displayText = 'Required Field Check Failed';
update lu_errorCodes set id = 2 where displayText = 'Failed Validation';
update lu_errorCodes set id = 3 where displayText = 'Failed Crosswalk';
update lu_errorCodes set id = 4 where displayText = 'Failed Macros';
update lu_errorCodes set id = 5 where displayText = 'System Error';
update lu_errorCodes set id = 6 where displayText = 'Invalid Configuration';
update lu_errorCodes set id = 7 where displayText = 'No Transactions Found';
update lu_errorCodes set id = 8 where displayText = 'Batch Handling Error';

/** gc 03122014 13:20 **/
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getFinalStatusIds` ()
proc_main:begin

set @finalStatusIds =  '11,12,13,16';

end proc_main$$
DELIMITER ;


drop procedure mmddyyyytoyyyymmdd;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
concat(substring(",srcField, ", 7,4), '",con1, "',  
substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- if we want to fail anything, we will set forcw to MACRO_ERROR
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

drop procedure MatchFAUpdateSF;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds,"));");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


drop procedure MatchFieldAUpdateFieldB;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

drop procedure yyyymmddTommddyyyy;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
concat(substring(",srcField, ", 6,2), '",con1, "',  
substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;



