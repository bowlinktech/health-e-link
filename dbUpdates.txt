/** grace 04182014 12:21PM **/
ALTER TABLE `universaltranslator`.`transactionin` 
ADD INDEX `idAndStatusId` (`id` ASC, `statusId` ASC);

drop PROCEDURE `universaltranslator`.`insertValidationErrors`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, fieldNo, errorid, configId,
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',fieldNo,',2, ',configId, ',' , vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,' , "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId not in (11,12,13,16));'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;

IF (transactionId != 0) THEN

set @stmt= concat(
'insert into transactionInerrors (batchUploadId, transactionInId, fieldNo, errorid, configId, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',fieldNo,',2, ', configId, ',', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,', "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where id = ', transactionId, ');'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;


END; 
END IF;


END$$
DELIMITER ;

drop PROCEDURE `universaltranslator`.`stripPhoneChars`;


DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`stripPhoneChars`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
	
	if (transactionId = 0) then
	BEGIN
		set part1 = concat("update transactiontranslatedIn JOIN (SELECT id from transactionIn WHERE configId = ",
	  configId,"  and batchId = ", batchUploadId, " and statusId not in (11,12,13,16)) as ti ON transactiontranslatedIn.transactionInId = ti.id SET transactiontranslatedIn.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	if (transactionId != 0) then
	BEGIN
	  set part1 = concat("update transactiontranslatedIn JOIN (SELECT id from transactionIn WHERE id = ",
	  transactionId, ") as ti ON transactiontranslatedIn.transactionInId = ti.id SET transactiontranslatedIn.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	
	set part2 = "', '');";
	set @stmt = concat(part1, varToReplace, part2);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;


/** Chad 4-21-14 @ 1 PM **/
ALTER TABLE `universaltranslator`.`transactionin` 
ADD COLUMN `messageStatus` INT NULL DEFAULT '1' COMMENT '1 = Open\n2 = Closed' AFTER `loadTableId`;

ALTER TABLE `universalTranslator`.`message_visitinfo` 
ADD COLUMN `messageStatus` INT NULL DEFAULT '1' COMMENT '1 = Open (Default)\n2 = Closed' AFTER `originalReferralId`;


/** grace 04.21.2014 5:02PM **/
drop procedure `universaltranslator`.`addCharToString`;
drop procedure `universaltranslator`.`MatchFAUpdateSF`;
drop procedure `universaltranslator`.`MatchFieldAUpdateFieldB`;
drop procedure `universaltranslator`.`mmddyyyytoyyyymmdd`;
drop procedure `universaltranslator`.`setFieldToNull`;
drop procedure `universaltranslator`.`yyyymmddTommddyyyy`;


DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`addCharToString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- we build sql here 

if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(",fieldA,", 1,",con2,"-1), '",con1,"', substring(",fieldA,", ",con2,",(length(",fieldA,")))) where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(",fieldA,", 1,",con2,"-1), '",con1,"', substring(",fieldA,", ",con2, 
",(length(",fieldA,")))) where ", @transactionTable ,"Id = ",transactionId, ";");
END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;



DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`MatchFAUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;
-- build our sql
if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
		and ",@transactionTable,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
		and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;



PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN

if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds,"));");

	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,
		"' and ",@transactionTable,"Id = ", transactionId,";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
				and ",@transactionTable,"Id in (select id from ",@transactionTable,
				" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
				and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id in (select id from ",@transactionTable,
	" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id = ", transactionId, ";");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`mmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 

if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 7,4), '",con1, "',  
		substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
		where ", @transactionTable ,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 7,4), '",con1, "',  
		substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
		where ", @transactionTable ,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- if we want to fail anything, we will set forcw to MACRO_ERROR
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;


DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`setFieldToNull`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldA," = null where ");

if (fieldB != 'F') then 
set @stmt = concat(@stmt, fieldB," = '",con2,"' and ");
end if;

if (transactionId = 0) then
		set @stmt =concat(@stmt, @transactionTable,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
END if;

if (transactionId != 0) then
		set @stmt =concat(@stmt, @transactionTable,"Id = ", transactionId, ";");

END if;
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`yyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 6,2), '",con1, "',  
		substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
		where ", @transactionTable ,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 6,2), '",con1, "',  
		substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
		where ", @transactionTable ,"Id = ", transactionId,";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

