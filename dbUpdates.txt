/** grace 06052014 10:02 **/

update configurationDataTranslations set categoryId = 1;

ALTER TABLE `universaltranslator`.`configurationdatatranslations` 
CHANGE COLUMN `categoryId` `categoryId` INT(11) NULL DEFAULT 1 COMMENT '2 pre - processing\n3 - post processing\n1 -  while- processing\n' ;


/** grace 06052014 11:03PM **/
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`) VALUES ('77', '2', 'Remove Transaction and Targets', 'removeTransactionTargets', 'removeTransactionTargets', 'Please enter field to check', 'Please enter transport method', 'Please enter org ids if there are multiple organizations (optional).  Leave blank to delete all target associated with batch.');
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=0 WHERE `ID`='77';

ALTER TABLE `universaltranslator`.`macro_names` 
CHANGE COLUMN `populateFieldA` `populateFieldA` BIT(1) NULL DEFAULT 1 ;



use universaltranslator;

drop procedure if exists removeTransactionTargets;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `removeTransactionTargets`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)

proc_main:begin

/**
fieldA - field to look for value
fieldB - not in use
con1 - value to match
con2 - target organizations to apply rule to
**/

-- 1. quering target transactionInIds from batchSummary
start transaction;

set @stmt1 = 
concat("select group_concat(transactionInId order by transactionInId, ',') into @listOfIds
 from batchUploadSummary where sourceConfigId = ", configId,  " and targetConfigId in 
(select configId from configurationTransportDetails where transportMethodid 
in (select id from ref_transportmethods where transportMethod = '", con1,"') 
and configId in (select id from configurations where status = 1 ");

set @stmt2 = '';

if (con2 != '') then
BEGIN
set @stmt2 = concat(" and orgId in (", con2, ")");
END;
end if;

set @stmt = concat(@stmt1, @stmt2, ") and batchId = ", batchId,");");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute


if (@listOfIds is not null) then
BEGIN
-- we have data, we delete from these tables
-- start our transaction here

set @del1 = concat("delete from transactionInErrors where transactionInId in (", @listOfIds, ");");
set @del2 = concat("delete from transactionInRecords where transactionInId in (", @listOfIds, ");");
set @del3 = concat("delete from transactionTranslatedIn where transactionInId in (", @listOfIds, ");");
set @del4 = concat("delete from transactionTarget where transactionInId in (", @listOfIds, ");");
set @del5 = concat("delete from batchUploadSummary where transactionInId in (", @listOfIds, ");");
set @del6 = concat("delete from transactionIn where id in (", @listOfIds, ");");



PREPARE delStmt from @del1;
EXECUTE delStmt;-- execute

PREPARE delStmt from @del2;
EXECUTE delStmt;-- execute

PREPARE delStmt from @del3;
EXECUTE delStmt;-- execute

PREPARE delStmt from @del4;
EXECUTE delStmt;-- execute

PREPARE delStmt from @del5;
EXECUTE delStmt;-- execute

PREPARE delStmt from @del6;
EXECUTE delStmt;-- execute

END;
end if;

EXECUTE stmt;-- execute

set @returnText = 'failed';
if (@listOfIds is not null) then
rollback;
else
set @returnText ='success';
COMMIT;
end if;

select @returnText;

end proc_main$$
DELIMITER ;



/** grace 10:44AM 06062014 **/
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='The file has failed either size, delimiter, type or is blank.' WHERE `id`='1';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='The file is uploaded and has met size, type, delimiter requirement.  It will be loaded into the database and translated.' WHERE `id`='2';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a user fixes transactions on ERG and resubmits them for process.' WHERE `id`='3';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is the intrim status that locks the file.  It is flagged so the scheudler won\'t pick it up for process.' WHERE `id`='4';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a file is processed but pending review' WHERE `id`='5';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when the batch has all final status.  It will be picked up by the scheudler and insert into UT db.' WHERE `id`='6';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when the entire batch is rejected after processing.  This status happens when every record in the batch fails or when the user selects fail batch when there are errored records' WHERE `id`='7';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a user enter in an ERG and decides to return and complete it later.' WHERE `id`='8';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='?? I am not sure what the difference between this and cancel (SCN - Cancelled) is. But this flags the batch to not be process. ' WHERE `id`='21';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a batch is delivered and at least one record (but not all) is viewed by an end user' WHERE `id`='22';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when an entire batch has been delivered and viewed by user.' WHERE `id`='23';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a batch are all in final status and inserted into the UT db.' WHERE `id`='24';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='STP', `displayText`='Submission Target Being Process', `description`='This is an interim status for when a submission target is being generated' WHERE `id`='25';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayText`='Submission Target Created', `description`='This is when a submission target is created but before it is delivered to users' WHERE `id`='28';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when an unexpected error happened during processing.  This usually will require code fixing or cw/macro update.  It means the cw, macro or something went wrong.' WHERE `id`='29';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='STPE', `displayText`='Submission Target Processing Errored' WHERE `id`='30';

INSERT INTO `universaltranslator`.`lu_ProcessStatus` (`id`, `category`, `displayCode`, `displayText`, `description`) VALUES ('37', 'transaction', 'TCP', 'Transaction Creation Processing', 'This is when a transaction is picked up by the scheduler and the translation is happening');


/** Grace 06062014 11:04PM **/
UPDATE `universaltranslator`.`macro_names` SET `Con1_Question`='Please enter value to match', `Con2_Question`='' WHERE `ID`='77';


UPDATE `universaltranslator`.`lu_ProcessStatus` SET `description`='This is when a transaction is loaded into our system in its raw format waiting to be process. It is sorted into F1, F2, F3 ... etc.' WHERE `id`='9';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TRP', `displayText`='Transaction Release Pending', `description`='This is an interim status we set the transaction to after it has been fixed in the ERG.  It will get pick up by the sceduler and all cw/macros/validations will be applied.' WHERE `id`='10';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TI', `displayText`='Trasaction Invalid', `description`='This is when a transaction is submitted without a valid configuration.  It is a final status.' WHERE `id`='11';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TREL', `displayText`='Transaction Released', `description`='This is when a transaction is processed. It is a Final Status' WHERE `id`='12';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TRJ', `displayText`='Transaction Rejected', `description`='This is when a transaction is rejected by user or set to reject as part of processing rules.  this is a final status.' WHERE `id`='13';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TE', `displayText`='Transaction Errored', `description`='This is when a transaction contains error that can be fixed in the ERG.' WHERE `id`='14';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TS', `displayText`='Transaction Saved', `description`='This is when an user created a message and save it half way so he/she can return later to fix' WHERE `id`='15';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TP', `displayText`='Transaction Passed', `description`='This is when a transaction contains errors but set to pass as part of the processing rules.  This is a final status.' WHERE `id`='16';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TC', `displayText`='Transaciton Closed', `description`='This is when user closes the transaction.  It is for ERG.  When a transcaction is closed, users will not be able to create feedback reports.' WHERE `id`='17';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TPP', `displayText`='Transaciton Pending Pickup', `description`='This is a target status. The transaction output is created and is waiting for use to view / download by file.' WHERE `id`='18';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TPO', `displayText`='Transaciton  Pending Output', `description`='This is a target stauts.  The transaction is ready for output generation.' WHERE `id`='19';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TREC', `displayText`='Transaction Received', `description`='This is a target status.  The user has downloaded or viewed the transaction. ' WHERE `id`='20';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayText`='Transaction Canceled', `description`='The is an ERG status. User goes online and hit the cancel button to stop all further activities for this transaction.' WHERE `id`='31';
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='TPE', `displayText`='Transaction Processing Error', `description`='This is when this transaciton errored due to some unforeseen error.  We flag this record and over on with batch.' WHERE `id`='33';
DELETE FROM `universaltranslator`.`lu_ProcessStatus` WHERE `id`='34';

/** grace 10:36PM 06062014 **/

use universaltranslator;

drop procedure if exists removeTransactionTargets;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `removeTransactionTargets`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)

proc_main:begin

/**
fieldA - field to look for value
fieldB - not in use
con1 - value to match


This is a pre-processing target for outbound that removes the target entirely from all tables
This is a per transaction macro
transaction will fail if in transactionId  is not a valid int and java codes will handle our transaction

**/

/** the id we get will be a transactionTargetId - we need to find the transactionInId since we need to clear
all tables as if the transaction never happended
**/
set @tInId = 0;
set @tOutId = 0;
set @batchInId = 0;
set @getTInId = concat("select transactionInId, id, batchUploadId into @tInId, @tOutId, @batchInId from transactionTarget where id = "
, transactionId ," and id in (select transactionTargetId from transactionTranslatedOut where "
,fieldA," = '",con1, "' and transactionTargetId = ", transactionId,");");


prepare stmt from @getTInId;
execute stmt;

set @processStatus = 'continue';
if (@tInId > 0) then
begin

call deleteTransaction (@tInId, @tOutId);
-- we need to update the original batch count

set @batchCount = 0;
set @batchInfoSql = concat("select count(*) into @batchCount from transactionIN where batchId = ",@batchInId);

prepare stmt from @batchInfoSql;
execute stmt;

-- now we update counts

set @batchInfoSql1 = concat("update batchUploads set totalrecordcount =  ", @batchCount, " where id = ",
@batchInId);

prepare stmt from @batchInfoSql1;
execute stmt;

set @processStatus = 'stop';
end;
end if;

select @processStatus;

end proc_main$$
DELIMITER ;


use universaltranslator;  

drop procedure if exists deleteTransaction;  


DELIMITER $$ 

CREATE DEFINER=`root`@`localhost` PROCEDURE `deleteTransaction`(in tInId int, in tOutId int)  
proc_main:begin  
set @stmt1 = concat("delete from message_Allergies where transactionInId = ", tInId , ";"); 
set @stmt2 = concat("delete from message_BestTimeToCall where transactionInId = ", tInId , ";"); 
set @stmt3 = concat("delete from message_Encounters where transactionInId = ", tInId , ";"); 
set @stmt4 = concat("delete from message_Exercises where transactionInId = ", tInId , ";"); 
set @stmt5 = concat("delete from message_FamMemMedicalConditions where transactionInId = ", tInId , ";"); 
set @stmt6 = concat("delete from message_FamilyMembers where transactionInId = ", tInId , ";"); 
set @stmt7 = concat("delete from message_FromOrg where transactionInId = ", tInId , ";"); 
set @stmt8 = concat("delete from message_FromProvider where transactionInId = ", tInId , ";"); 
set @stmt9 = concat("delete from message_GeneralHealths where transactionInId = ", tInId , ";"); 
set @stmt10 = concat("delete from message_HealthcareTeams where transactionInId = ", tInId , ";"); 
set @stmt11 = concat("delete from message_Immunizations where transactionInId = ", tInId , ";"); 
set @stmt12 = concat("delete from message_localcodes where transactionInId = ", tInId , ";"); 
set @stmt13 = concat("delete from message_MedicalConditions where transactionInId = ", tInId , ";"); 
set @stmt14 = concat("delete from message_Medications where transactionInId = ", tInId , ";"); 
set @stmt15 = concat("delete from message_Misc where transactionInId = ", tInId , ";"); 
set @stmt16 = concat("delete from message_PatientAddresses where transactionInId = ", tInId , ";"); 
set @stmt17 = concat("delete from message_Patients where transactionInId = ", tInId , ";"); 
set @stmt18 = concat("delete from message_patientIds where transactionInId = ", tInId , ";"); 
set @stmt19 = concat("delete from message_Payers where transactionInId = ", tInId , ";"); 
set @stmt20 = concat("delete from message_Procedures where transactionInId = ", tInId , ";"); 
set @stmt21 = concat("delete from message_SocialHistories where transactionInId = ", tInId , ";"); 
set @stmt22 = concat("delete from message_TestResults where transactionInId = ", tInId , ";"); 
set @stmt23 = concat("delete from message_ToOrg where transactionInId = ", tInId , ";"); 
set @stmt24 = concat("delete from message_ToProvider where transactionInId = ", tInId , ";"); 
set @stmt25 = concat("delete from message_VisitInfo where transactionInId = ", tInId , ";"); 
set @stmt26 = concat("delete from message_races where transactionInId = ", tInId , ";"); 
set @stmt27 = concat("delete from transactionOutNotes where transactionTargetId = ", @tOutId , ";");  
set @stmt28 = concat("delete from transactionTranslatedOut where transactionTargetId = ", @tOutId , ";");  
set @stmt29 = concat("delete from transactionOutErrors where transactionTargetId = ", @tOutId , ";");  
set @stmt30 = concat("delete from transactionOutRecords where transactionTargetId = ", @tOutId , ";");  
set @stmt31 = concat("delete from batchDownloadSummary where transactionTargetId = ", @tOutId , ";");  
set @stmt32 = concat("delete from transactionTarget where id = ", @tOutId , ";");        
set @stmt33 = concat("delete from transactionInErrors where transactionInId = ", @tInId , ";");  
set @stmt34 = concat("delete from transactionInRecords where transactionInId = ", @tInId , ";");  
set @stmt35 = concat("delete from transactionTranslatedIn where transactionInId = ", @tInId , ";");  
set @stmt36 = concat("delete from batchUploadSummary where transactionInId = ", @tInId , ";");  
set @stmt37 = concat("delete from transactionIn where id = ", @tInId , ";");     
prepare stmt from @stmt1; execute stmt;  
prepare stmt from @stmt2; execute stmt;  
prepare stmt from @stmt3; execute stmt;  
prepare stmt from @stmt4; execute stmt;  
prepare stmt from @stmt5; execute stmt;  
prepare stmt from @stmt6; execute stmt;  
prepare stmt from @stmt7; execute stmt;  
prepare stmt from @stmt8; execute stmt;  
prepare stmt from @stmt9; execute stmt;  
prepare stmt from @stmt10; execute stmt;  
prepare stmt from @stmt11; execute stmt;  
prepare stmt from @stmt12; execute stmt;  
prepare stmt from @stmt13; execute stmt;  
prepare stmt from @stmt14; execute stmt;  
prepare stmt from @stmt15; execute stmt;  
prepare stmt from @stmt16; execute stmt;  
prepare stmt from @stmt17; execute stmt;  
prepare stmt from @stmt18; execute stmt;  
prepare stmt from @stmt19; execute stmt;  
prepare stmt from @stmt20; execute stmt;
prepare stmt from @stmt21; execute stmt;  
prepare stmt from @stmt22; execute stmt;  
prepare stmt from @stmt23; execute stmt;  
prepare stmt from @stmt24; execute stmt;  
prepare stmt from @stmt25; execute stmt;  
prepare stmt from @stmt26; execute stmt;  
prepare stmt from @stmt27; execute stmt;  
prepare stmt from @stmt28; execute stmt; 
prepare stmt from @stmt29; execute stmt;  
prepare stmt from @stmt30; execute stmt;  
prepare stmt from @stmt31; execute stmt;  
prepare stmt from @stmt32; execute stmt;  
prepare stmt from @stmt33; execute stmt;  
prepare stmt from @stmt34; execute stmt;  
prepare stmt from @stmt35; execute stmt;  
prepare stmt from @stmt36; execute stmt;  
prepare stmt from @stmt37; execute stmt;  

end proc_main$$ 
DELIMITER ; 

UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='77';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='76';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='74';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='75';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='68';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='69';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='70';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='71';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='72';
UPDATE `universaltranslator`.`macro_names` SET `populateFieldA`=1 WHERE `ID`='73';


/** Chad 6/9/14 @ 11:01 AM **/
DROP TABLE `universaltranslator`.`configurationpostprocessing`, `universaltranslator`.`configurationpreprocessing`;


/** all above updates are applied to dev and test DPH grace 06092014 10:36PM **/

/** grace 06102014 2:54 AM **/
use universalTranslator;

drop procedure if exists appendPrependString;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendPrependString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
fieldA - which field would you like to append and / or prepend?
con1 - what string would you like to prepend?
con2 - what string would you like to append?
**/
-- we build sql here 



if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat('", con1, "', ", fieldA, ", '", con2,"') where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat('", con1, "', ", fieldA, ", '", con2,"') where ", @transactionTable ,"Id = ",transactionId, ";");
END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

INSERT INTO `universaltranslator`.`Macro_Names` (`ID`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('79', 'Prepend and/or Append Strings', 'Prepend Append String', 'appendPrependString', 'Please enter field that append and/or prepend to', 'Please enter value you would like to prepend', 'Please enter value you would like to append', 1);

/** grace 06102014 03:10 AM **/

use universalTranslator;

drop procedure if exists stripLeadingChars;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripLeadingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
fieldA - which field would you like to trim  leading characters from?
con1 - what string would you like to trim?

**/
-- we build sql here 



if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = TRIM(LEADING '",con1,"' FROM ",fieldA,") where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = TRIM(LEADING '",con1,"' FROM ",fieldA,") where ", @transactionTable ,"Id = ",transactionId, ";");
END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

INSERT INTO `universaltranslator`.`Macro_Names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `populateFieldA`) VALUES ('80', '1', 'String leading characters', 'StringLeading', 'stripLeadingChars', 'Please enter field to strip leading characters from', 'Please enter leading characters', 1);


/*** separator ***/

use universalTranslator;

drop procedure if exists stripTrailingChars;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripTrailingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
fieldA - which field would you like to trim  leading characters from?
con1 - what string would you like to trim?

**/
-- we build sql here 



if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = TRIM(TRAILING '",con1,"' FROM ",fieldA,") where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = TRIM(TRAILING '",con1,"' FROM ",fieldA,") where ", @transactionTable ,"Id = ",transactionId, ";");
END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

INSERT INTO `universaltranslator`.`Macro_Names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `populateFieldA`) VALUES ('81', '1', 'Strip Trailing', 'Strip trailing character', 'stripTrailingChars', 'Please enter field to strip trailing character(s) from', 'Please enter character(s) to remove', 1);
UPDATE `universaltranslator`.`Macro_Names` SET `Macro_Name`='Stripleading characters', `Macro_Short_Name`='StripLeading' WHERE `ID`='80';

/** grace 06102014 11:41 AM **/
UPDATE `universaltranslator`.`lu_ProcessStatus` SET `displayCode`='SFR', `description`='This is when resets a SFTP or Rhapsody file.  The original file is copied back to input folder and a new batch number is reassigned.' WHERE `id`='35';


/** Chad 6/10/14 @ 2:45 PM **/
ALTER TABLE `universaltranslator`.`configurationhl7elementvalues` 
ADD COLUMN `fieldAppendText` VARCHAR(255) NULL DEFAULT NULL AFTER `fieldDescriptor`;

DELETE FROM `universaltranslator`.`lu_internalmessagestatus` WHERE `id`='9';


/** Chad 6-11-14 @ 12:28 AM **/
CREATE TABLE `universaltranslator`.`batchMultipleTargets` (
  `id` INT NOT NULL,
  `batchId` INT NOT NULL,
  `tgtConfigId` INT NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `id_UNIQUE` (`id` ASC));

ALTER TABLE `universaltranslator`.`batchMultipleTargets` 
CHANGE COLUMN `id` `id` INT(11) NOT NULL AUTO_INCREMENT ;

/** Chad 6-12-14 @ 11:19 AM **/
ALTER TABLE `universaltranslator`.`message_misc` 
ADD COLUMN `field11` VARCHAR(500) NULL DEFAULT NULL AFTER `field10`,
ADD COLUMN `field12` VARCHAR(500) NULL DEFAULT NULL AFTER `field11`,
ADD COLUMN `field13` VARCHAR(500) NULL DEFAULT NULL AFTER `field12`,
ADD COLUMN `field14` VARCHAR(500) NULL DEFAULT NULL AFTER `field13`,
ADD COLUMN `field15` VARCHAR(500) NULL DEFAULT NULL AFTER `field14`;

/** Grace 06-12-2014 7:21 PM **/
ALTER TABLE `universaltranslator`.`moveFilesLog` 
ADD COLUMN `notes` TEXT NULL AFTER `method`;


/** all above updates are deployed on test and dev  06122014 8:16PM **/


/** Chad 6-12-14 @ 11:36 PM **/
ALTER TABLE `universaltranslator`.`rel_crosswalkdata` 
CHANGE COLUMN `targetValue` `targetValue` VARCHAR(255) NOT NULL ,
CHANGE COLUMN `descValue` `descValue` VARCHAR(255) NOT NULL ;