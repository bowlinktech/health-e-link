

/** 10192015 Chad  **/
ALTER TABLE `healthelink`.`configurationtransportdetails` 
ADD COLUMN `HL7PDFSampleTemplate` VARCHAR(45) NULL DEFAULT NULL AFTER `attachmentNote`;

/** 01262016 Chad **/
ALTER TABLE `healthelink`.`organizations` 
ADD COLUMN `headerLogo` VARCHAR(75) NULL DEFAULT NULL AFTER `parentId`,
ADD COLUMN `headerBackground` VARCHAR(75) NULL DEFAULT NULL AFTER `headerLogo`;

ALTER TABLE `healthelink`.`users` 
ADD COLUMN `receiveEmailAlert` BIT(1) NULL DEFAULT b'0' AFTER `encryptedPw`;

/** 02212016 Grace **/
ALTER TABLE `healthelink`.`configurationtransportdetails` 
ADD COLUMN `massTranslation` BIT(1) NULL DEFAULT 0 AFTER `HL7PDFSampleTemplate`;

/** 02222016 Grace **/
INSERT INTO `healthelink`.`lu_processstatus` (`id`, `category`, `displayCode`, `displayText`, `description`, `status`, `isCustom`, `endUserDisplayCode`, `endUserDisplayText`, `endUserDescription`) VALUES ('40', 'transaction', 'TOC', 'Transaction Output Created', 'Normal condition: The transaction output is created.', 1, 0, 'TOC', 'Transaction Output Created', 'Normal condition: The transaction output is created.');
INSERT INTO `healthelink`.`lu_errorcodes` (`id`, `displayText`, `description`, `isCustom`, `status`) VALUES ('30', 'Multiple Target Configurations', 'Multiple Target Configurations found for mass translation batch', 0, 1);

USE `healthelink`;
DROP procedure IF EXISTS `getFinalStatusIds`;

DELIMITER $$
USE `healthelink`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getFinalStatusIds`()
proc_main:begin

set @finalStatusIds =  '11,12,13,16,18,20';

end proc_main$$

DELIMITER ;


USE `healthelinkdev`;
DROP procedure IF EXISTS `setSqlForOutboundConfig`;

DELIMITER $$
USE `healthelinkdev`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setSqlForOutboundConfig`(in inConfigId int, in batchDownloadId int)
proc_main:begin
drop TEMPORARY TABLE if exists tempOut;
CREATE TEMPORARY TABLE tempOut
as (select min(fieldNo) as fieldNo, saveToTableName, savetotablecol, configId, batchDownloadId
from configurationFormFields where configId = inConfigId
and saveToTableName != ''
group by savetotablecol, saveToTableName);
select batchDownloadId, 
group_concat(fieldNo ORDER BY fieldNo SEPARATOR ',')as fieldNos, 
group_concat(savetotablecol ORDER BY fieldNo SEPARATOR ',') as saveToCols
, saveToTableName, group_concat(
concat(
'group_concat(COALESCE(',savetotablecol, ', ''NULL'') order by ', saveToTableName, '.id separator ''^^^^^'' ) as ', savetotablecol
) 
ORDER BY fieldNo SEPARATOR ', ')  as selectFields, 
group_concat(concat('tto.f', fieldNo, ' = selectTbl.' , savetotablecol)  ORDER BY fieldNo SEPARATOR ', ')  as updateFields,
configId
FROM tempOut
where configId = inConfigId
GROUP BY saveToTableName
ORDER BY saveToTableName;

end proc_main$$

DELIMITER ;

/** 02232016 Grace **/
INSERT INTO `healthelinkdev`.`lu_processstatus` (`id`, `category`, `displayCode`, `displayText`, `description`, `endUserDisplayCode`, `endUserDisplayText`, `endUserDescription`) VALUES ('41', 'Batch', 'TBJ', 'Target Batch Rejected', 'Error condition: One or more errors occurred in the submission and the submission was rejected. Please review the audit report.', 'TBJ', 'Target Batch Rejected', 'Error condition: One or more errors occurred in the submission and the submission was rejected. Please review the audit report.');

USE `healthelinkdev`;
DROP procedure IF EXISTS `stripPhoneCharsOutbound`;

DELIMITER $$
USE `healthelinkdev`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripPhoneCharsOutbound`(in vtType int, in fieldNo int,
in batchDLId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(300) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.'; 
	
	if (transactionId = 0) then
	BEGIN
		set part1 = concat("update transactiontranslatedOut JOIN (SELECT id from transactionTarget WHERE configId = ",
	  configId,"  and batchDLId = ", batchDLId, " and statusId not in (11,12,13,16,18,20)) as ti ON transactiontranslatedOut.transactionTargetId = ti.id SET transactiontranslatedOut.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	if (transactionId != 0) then
	BEGIN
	  set part1 = concat("update transactiontranslatedOut JOIN (SELECT id from transactionTarget WHERE id = ",
	  transactionId, ") as ti ON transactiontranslatedOut.transactionTargetId = ti.id SET transactiontranslatedIn.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	
	set part2 = "', '');";
	set @stmt = concat(part1, varToReplace, part2);
    PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END $$

DELIMITER ;

USE `healthelinkdev`;
DROP procedure IF EXISTS `insertValidationErrorsOutbound`;

DELIMITER $$
USE `healthelinkdev`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrorsOutbound`(in vtType int, in fieldNo int,
in batchDownloadId int, in configId int, in transactionId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `stripPhoneCharsOutbound`(vtType, fieldNo, batchDownloadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE; 

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactionOuterrors (batchDownloadId, transactionTargetId, fieldNo, errorid, configId,
validationTypeId) SELECT ', batchDownloadId, ', transactionTargetId, ',fieldNo,',2, ',configId, ',' , vtType,'  
 FROM transactionTranslatedOut WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,' , "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionTargetId 
in (select id from transactionTarget where batchDLId = ', batchDownloadId,' and configId = ', configId,' and statusId not in (11,12,13,16,18,20));'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;

IF (transactionId != 0) THEN

set @stmt= concat(
'insert into transactionOuterrors (batchDownloadId, transactionTargetId, fieldNo, errorid, configId, 
validationTypeId) SELECT ', batchDownloadId, ', transactionInId, ',fieldNo,',2, ', configId, ',', vtType,'  
 FROM transactionTranslatedOut WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,', "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionTargetId 
in (select id from transactionTarget where id = ', transactionId, ');'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;


END; 
END IF;

 
END$$

DELIMITER ;

/** 06142016 Chad **/
ALTER TABLE `healthelinkdev`.`message_patients` 
ADD COLUMN `clientId` INT(11) NOT NULL DEFAULT '0' AFTER `miscField10`;


/** grace 10212016 **/
CREATE TABLE `healthelinkdev`.`transactionindetailauditerrors` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `batchUploadId` INT NOT NULL,
  `configId` INT NOT NULL,
  `transactionInId` INT NOT NULL,
  `fieldNo` INT NOT NULL,
  `errorId` INT NOT NULL,
  `errorData` TEXT NULL,
  PRIMARY KEY (`id`, `batchUploadId`, `configId`, `transactionInId`, `fieldNo`, `errorId`));
  
  
  ALTER TABLE `healthelinkdev`.`transactionindetailauditerrors` 
ADD COLUMN `reportField1Data` VARCHAR(250) NULL AFTER `errorData`,
ADD COLUMN `reportField2Data` VARCHAR(250) NULL AFTER `reportField1Data`,
ADD COLUMN `reportField3Data` VARCHAR(250) NULL AFTER `reportField2Data`;

USE `healthelinkdev`;
DROP procedure IF EXISTS `populateAuditReport`;

DELIMITER $$
USE `healthelinkdev`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateAuditReport`(in inConfigId int, 
in inBatchId int)
proc_main:begin

delete from transactionIndetailauditerrors where batchuploadId = inBatchId and configId = inConfigId;

insert into transactionIndetailauditerrors 
(batchUploadId, configId, transactionInId, fieldNo, errorId)
select batchUploadId, configId, transactionInId, fieldno,  errorId
from transactionINErrors where batchuploadId = inBatchId and configId = inConfigId;

 
-- next update error details for macro_names, validation and cw

-- update macro name
UPDATE 
  transactionIndetailauditerrors
  JOIN (select transactionInId matchid, macro_Name as label 
from macro_names, transactionINErrors where macro_Names.id = transactionINErrors.macroId and batchuploadId = inBatchId) tbl_concat
     ON transactionIndetailauditerrors.transactionInId = tbl_concat.matchid
SET transactionIndetailauditerrors.errorDetails = tbl_concat.label 
WHERE transactionIndetailauditerrors.batchuploadid = inBatchId and errorId = 4;

-- update cw name
UPDATE 
  transactionIndetailauditerrors
  JOIN (select transactionInId matchid, name as label 
from crosswalks, transactionINErrors where crosswalks.id = transactionINErrors.cwId and batchuploadId = inBatchId) tbl_concat
     ON transactionIndetailauditerrors.transactionInId = tbl_concat.matchid
SET transactionIndetailauditerrors.errorDetails = tbl_concat.label 
WHERE transactionIndetailauditerrors.batchuploadid = inBatchId and errorId =  3;

-- update validation type
UPDATE 
  transactionIndetailauditerrors
  JOIN (select transactionInId matchid, validationType as label 
from ref_validationtypes, transactionINErrors where ref_validationtypes.id = transactionINErrors.validationTypeId and batchuploadId = inBatchId) tbl_concat
     ON transactionIndetailauditerrors.transactionInId = tbl_concat.matchid
SET transactionIndetailauditerrors.errorDetails = tbl_concat.label 
WHERE transactionIndetailauditerrors.batchuploadid = inBatchId and errorId =  2;

-- update field label
UPDATE 
  transactionIndetailauditerrors
  JOIN (select fieldNo as matchid, fieldLabel as label 
from configurationformfields where configId = inConfigId) tbl_concat
     ON transactionIndetailauditerrors.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors.fieldName = tbl_concat.label 
WHERE transactionIndetailauditerrors.batchuploadid = inBatchId;

-- see if we want to return something
select '';

end proc_main$$

DELIMITER ;


ALTER TABLE `healthelinkdev`.`transactionindetailauditerrors` 
ADD INDEX `batchUploadId_idx` (`batchUploadId` ASC);
ALTER TABLE `healthelinkdev`.`transactionindetailauditerrors` 
ADD CONSTRAINT `batchUploadId`
  FOREIGN KEY (`batchUploadId`)
  REFERENCES `healthelinkdev`.`transactionindetailauditerrors` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;
  
  
  /** grace 12.25.16 11:21PM **/
  ALTER TABLE `healthelink`.`organizations` 
ADD COLUMN `town` VARCHAR(45) NULL AFTER `orgType`,
ADD COLUMN `county` VARCHAR(45) NULL AFTER `town`,
ADD COLUMN `infoURL` VARCHAR(255) NULL AFTER `county`;


ALTER TABLE `healthelink`.`organizations` 
CHANGE COLUMN `public` `publicOrg` BIT(1) NOT NULL DEFAULT b'1' COMMENT '1 = Public\n0 = Private' ;


 /** grace 05292017 **/
 DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `GreaterThanEqualFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," >= '",con1,"'
				and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," >= '",con1,"'
				and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id in (select id from ",@transactionTable,
	" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id = ", transactionId, ";");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;
 
 
INSERT INTO `healthelink`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('106', '1', 'Update to con2 when A is Greater than equal to con1', 'GreaterThanEqualFieldAUpdateFieldB', 'GreaterThanEqualFieldAUpdateFieldB', 'Please enter field to check against', 'Please enter column to update', 'Please enter the number it should be greater than or equal to', 'Please enter constant to set', 1);

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `lessThanEqualFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," <= '",con1,"'
				and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," <= '",con1,"'
				and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id in (select id from ",@transactionTable,
	" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id = ", transactionId, ";");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


INSERT INTO `healthelink`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('107', '1', 'Update to con2 when A is less than equal to con1', 'lessThanEqualFieldAUpdateFieldB', 'lessThanEqualFieldAUpdateFieldB', 'Please enter field to check against', 'Please enter column to update', 'Please enter the number it should be less than or equal to', 'Please enter constant to set', 1);

INSERT INTO `healthelink`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('108', '1', 'Update TF to con2 when TF is blank and FieldA is con1', 'IfMatchFieldAAndTFBlankSetTFValue', 'IfMatchFieldAAndTFBlankSetTFValue', 'Please enter field to check against', 'Please enter column to update', 'Please enter the value of field A', 'Please enter value to set target field to if blank', 1);

INSERT INTO `healthelink`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('109', '1', 'Update FieldA to con2 when SF is con1 else FieldA to null', 'ifSFMatchCon1ThenCon2ElseNull', 'ifSFMatchCon1ThenCon2ElseNull', 'Please enter field to update', 'Please enter column to update', '', 'Please enter SF field value', 'Please enter target value');


USE `healthelink`;
DROP procedure IF EXISTS `healthelink`.`IfMatchFieldAAndTFBlankSetTFValue`;

DELIMITER $$
USE `healthelink`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfMatchFieldAAndTFBlankSetTFValue`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP replaces the entire columm with single value
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2, "' 
     where " ,fieldA, " = '",con1, "' and length(",fieldB,") = 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	END if;


if (transactionId != 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '", con2,"' where ", fieldA, " = '", con1, "' and length(",fieldB,") = 0 and ",
	@transactionTable,"Id = ", transactionId,";");
	END if;


PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
DEALLOCATE PREPARE stmt;

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;


-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$

DELIMITER ;
;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFMatchCon1ThenCon2ElseNull`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldA, " = case when ", srcField, " = '",con1,"' then '", con2 , "' else NULL end",
				" where  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	           
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldA, " = case when ", srcField, " = '",con1,"' then '", con2 , "' else NULL end",
				 " where and ",@transactionTable,"Id = ", transactionId, ";");
	
    
    
    END;
	END if;
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
    DEALLOCATE PREPARE stmt;

-- insert into sqlstmts (sqlstmt) values(@stmt);

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

UPDATE `healthelink`.`macro_names` SET `FieldB_Question`='', `Con1_Question`='Please enter value to match for SF', `Con2_Question`='Please enter value to update fieldA to' WHERE `ID`='109';

 /** 06192017 **/
 CREATE TABLE `rel_configexceldetails` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `orgId` int(11) NOT NULL,
  `configId` int(11) NOT NULL,
  `startRow` int(11) NOT NULL,
  `discardLastRows` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
  
  
