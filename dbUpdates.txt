/** grace 04182014 12:21PM **/
ALTER TABLE `universaltranslator`.`transactionin` 
ADD INDEX `idAndStatusId` (`id` ASC, `statusId` ASC);

USE `universalTranslator`;
DROP procedure IF EXISTS `insertValidationErrors`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, fieldNo, errorid, configId,
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',fieldNo,',2, ',configId, ',' , vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,' , "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId not in (11,12,13,16));'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;

IF (transactionId != 0) THEN

set @stmt= concat(
'insert into transactionInerrors (batchUploadId, transactionInId, fieldNo, errorid, configId, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',fieldNo,',2, ', configId, ',', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,', "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where id = ', transactionId, ');'
);

BEGIN -- true
		PREPARE stmt from @stmt;
		EXECUTE stmt;


END; 
END IF;


END$$
DELIMITER ;

drop PROCEDURE IF EXISTS `universaltranslator`.`stripPhoneChars`;


DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`stripPhoneChars`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
	
	if (transactionId = 0) then
	BEGIN
		set part1 = concat("update transactiontranslatedIn JOIN (SELECT id from transactionIn WHERE configId = ",
	  configId,"  and batchId = ", batchUploadId, " and statusId not in (11,12,13,16)) as ti ON transactiontranslatedIn.transactionInId = ti.id SET transactiontranslatedIn.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	if (transactionId != 0) then
	BEGIN
	  set part1 = concat("update transactiontranslatedIn JOIN (SELECT id from transactionIn WHERE id = ",
	  transactionId, ") as ti ON transactiontranslatedIn.transactionInId = ti.id SET transactiontranslatedIn.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
	END;
	END if;

	
	set part2 = "', '');";
	set @stmt = concat(part1, varToReplace, part2);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;


/** Chad 4-21-14 @ 1 PM **/
ALTER TABLE `universaltranslator`.`transactionin` 
ADD COLUMN `messageStatus` INT NULL DEFAULT '1' COMMENT '1 = Open\n2 = Closed' AFTER `loadTableId`;

ALTER TABLE `universalTranslator`.`message_visitinfo` 
ADD COLUMN `messageStatus` INT NULL DEFAULT '1' COMMENT '1 = Open (Default)\n2 = Closed' AFTER `originalReferralId`;


/** grace 04.21.2014 5:02PM **/
drop procedure IF EXISTS `universaltranslator`.`addCharToString`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`addCharToString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- we build sql here 

if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(",fieldA,", 1,",con2,"-1), '",con1,"', substring(",fieldA,", ",con2,",(length(",fieldA,")))) where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(",fieldA,", 1,",con2,"-1), '",con1,"', substring(",fieldA,", ",con2, 
",(length(",fieldA,")))) where ", @transactionTable ,"Id = ",transactionId, ";");
END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;


drop procedure IF EXISTS `universaltranslator`.`MatchFAUpdateSF`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`MatchFAUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;
-- build our sql
if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
		and ",@transactionTable,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
		and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;



PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN

if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds,"));");

	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,
		"' and ",@transactionTable,"Id = ", transactionId,";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


drop procedure IF EXISTS  `universaltranslator`.`MatchFieldAUpdateFieldB`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
				and ",@transactionTable,"Id in (select id from ",@transactionTable,
				" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
				and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
if (transactionId = 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id in (select id from ",@transactionTable,
	" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
	and ",@transactionTable,"Id = ", transactionId, ";");
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
	END;
	END if;

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


drop procedure IF EXISTS `universaltranslator`.`mmddyyyytoyyyymmdd`;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`mmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 

if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 7,4), '",con1, "',  
		substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
		where ", @transactionTable ,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, "));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 7,4), '",con1, "',  
		substring(", srcField, ", 1,2),'",con1,"' ,substring(",srcField, ", 4,2))
		where ", @transactionTable ,"Id = ", transactionId, ";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- if we want to fail anything, we will set forcw to MACRO_ERROR
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

drop procedure IF EXISTS  `universaltranslator`.`setFieldToNull`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`setFieldToNull`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldA," = null where ");

if (fieldB != 'F') then 
set @stmt = concat(@stmt, fieldB," = '",con2,"' and ");
end if;

if (transactionId = 0) then
		set @stmt =concat(@stmt, @transactionTable,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
END if;

if (transactionId != 0) then
		set @stmt =concat(@stmt, @transactionTable,"Id = ", transactionId, ";");

END if;
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN

END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

drop procedure IF EXISTS `universaltranslator`.`yyyymmddTommddyyyy`;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`yyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (length(fieldA) = 0) then
set fieldA = srcField;
end if;

if (length(con1) = 0) then
set con1 = "/";
end if;

-- we build sql here 
if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 6,2), '",con1, "',  
		substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
		where ", @transactionTable ,"Id in (select id from ",@transactionTable,
		" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ", @translatedTable," set ",fieldA," = 
		concat(substring(",srcField, ", 6,2), '",con1, "',  
		substring(", srcField, ", 9,2),'",con1,"' ,substring(",srcField, ", 1,4))
		where ", @transactionTable ,"Id = ", transactionId,";");
	END;
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
select '';

end proc_main$$
DELIMITER ;

/** Chad 4-22-14 @ 3:48 pm **/
USE `universalTranslator`;
DROP procedure IF EXISTS `closeOutReferral`;

DELIMITER $$
USE `universalTranslator`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `closeOutReferral`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- Need to get the value of the srcField to see what the referral status is set to
begin

set @stmt = concat("select ", " ", srcField, " INTO @referralStatus from ", @translatedTable, " where transactionInId = ", transactionId);

PREPARE stmt1 FROM @stmt;
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;

if(@referralStatus = 2) then

	BEGIN 
		set @stmt = concat("select transactionInId INTO @transactionInId from transactionTarget where id = (select transactionTargetId from transactionIn where id = ", transactionId, " )");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @stmt = concat("update transactionIn set messageStatus = 2 where id = ", @transactionInId);
		PREPARE stmt from @stmt;
		EXECUTE stmt;

	END;

END if;


END;

-- see if we want to return something
select '';

END proc_main$$

DELIMITER ;



/** Grace 04222014 3:49PM **/
drop procedure IF EXISTS `universaltranslator`.`replacechars`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`replacechars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- build our sql
if (transactionId = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = replace(",fieldA,", '",con1,"','",con2,"') where ",@transactionTable,"Id in (select id from ",@transactionTable,
				" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
	END if;


if (transactionId != 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = replace(",fieldA,", '",con1,"','",con2,"') where ",
	@transactionTable,"Id = ", transactionId,";");
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;


-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


INSERT INTO `universaltranslator`.`macro_names` (`id`,`Category`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `Con1_Question`, `Con2_Question`) VALUES (72, 'String manipulation', 'Replace chars', 'replaceChars', 'replaceChars', 'Please enter character(s) that you would like to replace', 'Please enter new character(s).');



/** grace 04222014 06:00PM **/
ALTER TABLE `universaltranslator`.`message_visitinfo` 
DROP INDEX `messContraFK_idx` ;


ALTER TABLE `universaltranslator`.`message_visitinfo` 
ADD INDEX `noContraFK_idx` (`noContraceptiveId` ASC),
ADD INDEX `primContraFK_idx` (`primaryContraceptiveId` ASC),
ADD INDEX `secondContraFK_idx` (`secondContraceptiveId` ASC);
ALTER TABLE `universaltranslator`.`message_visitinfo` 
ADD CONSTRAINT `noContraFK`
  FOREIGN KEY (`noContraceptiveId`)
  REFERENCES `universaltranslator`.`lu_noContraceptiveReasons` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION,
ADD CONSTRAINT `primContraFK`
  FOREIGN KEY (`primaryContraceptiveId`)
  REFERENCES `universaltranslator`.`lu_contraceptives` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION,
ADD CONSTRAINT `secondContraFK`
  FOREIGN KEY (`secondContraceptiveId`)
  REFERENCES `universaltranslator`.`lu_contraceptives` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

  
/** grace 04222014 06:49PM **/
USE `universalTranslator`;
DROP procedure IF EXISTS `trimField`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `universaltranslator`.`trimField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- build our sql
if (transactionId = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA, " = TRIM(REPLACE(REPLACE(" , fieldA , ", '\\n', ''), '\\r', '')) where ",@transactionTable,"Id in (select id from ",@transactionTable,
				" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,"));");
	END if;

if (transactionId != 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA, " = Trim(REPLACE(REPLACE(" , fieldA , 
	", '\\n', ''), '\\r', '')) where ",@transactionTable,"Id = ",transactionId, ";");
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;


-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

INSERT INTO `universaltranslator`.`macro_names` (`id`,`Category`, `Macro_Name`, `Macro_Short_Name`, `Formula`) VALUES (73, 'String manipulation', 'Trim Whitespaces', 'trimField', 'trimField');


/** Chad 04-23-14 @ 2:43 PM **/
USE `universalTranslator`;
DROP procedure IF EXISTS `closeOutReferral`;

DELIMITER $$
USE `universalTranslator`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `closeOutReferral`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- Need to get the value of the srcField to see what the referral status is set to
begin

if(transactionId > 0) then
	set @stmt = concat("select ", " ", srcField, " INTO @referralStatus from ", @translatedTable, " where transactionInId = ", transactionId);

	PREPARE stmt1 FROM @stmt;
	EXECUTE stmt1;
	DEALLOCATE PREPARE stmt1;

	if(@referralStatus = 2) then

		BEGIN 
			set @stmt = concat("select transactionInId INTO @transactionInId from transactionTarget where id = (select transactionTargetId from transactionIn where id = ", transactionId, " )");
			
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

			set @stmt = concat("update transactionIn set messageStatus = 2 where id = ", @transactionInId);
			PREPARE stmt from @stmt;
			EXECUTE stmt;

		END;

	END if;

	
else 

	begin

	DECLARE transId int;
	DECLARE done INT DEFAULT FALSE;
	
	DECLARE cur CURSOR for select id from transactionin where batchId = batchId;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
	
	OPEN cur;

	read_loop: LOOP

		IF done THEN
			LEAVE read_loop;
		END IF;

		FETCH cur INTO transId;
		
		if(transId > 0) then
			set @stmt = concat("select ", " ", srcField, " INTO @referralStatus from ", @translatedTable, " where transactionInId = ", transId);

			PREPARE stmt1 FROM @stmt;
			EXECUTE stmt1;
			DEALLOCATE PREPARE stmt1;

			if(@referralStatus = 2) then

				BEGIN 
					set @stmt = concat("select transactionInId INTO @transactionInId from transactionTarget where id = (select transactionTargetId from transactionIn where id = ", transId, " )");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;

					set @stmt = concat("update transactionIn set messageStatus = 2 where id = ", @transactionInId);
					PREPARE stmt from @stmt;
					EXECUTE stmt;

				END;

			END if;
		end if;

	END LOOP;
	CLOSE cur; 

	end;

end if;


END;

select '';

END proc_main$$

DELIMITER ;


/** grace 04242014 9:58PM **/
ALTER TABLE `universaltranslator`.`userActivity` 
ADD COLUMN `featureId` INT NULL AFTER `userId`;


