use healthelink;

drop procedure if exists listtorows;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ListToRows`(in fieldA varchar(20), in cwId int /** con1 **/, 
in listOfValues varchar(255), in dropValue  varchar(255) /**con2 - y/n**/, 
in foroutboundProcessing boolean, in transactionId int)
BEGIN

/** create our temp table **/
drop table if exists listToRowsTemp;

CREATE Temporary TABLE `listToRowsTemp` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sourceValue` varchar(255) DEFAULT NULL,
  `priority` int DEFAULT NULL,
  `matchValue` varchar(255) DEFAULT NULL,
  `transactionId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
);


	Set @stopVal = 0;
	select LENGTH(listOfValues) - LENGTH(REPLACE(listOfValues, ',', '')) into @stopVal;
	set @stopVal = @stopVal + 2;
	SET @i = 1;

  REPEAT
    INSERT INTO listToRowsTemp (sourcevalue)
      SELECT  strSplit(listOfValues, ',', @i) from transactionIn limit 1;
    SET @i = @i + 1;
    UNTIL @i = @stopVal
  END REPEAT;

/** make integers **/

update listToRowsTemp set matchvalue = IF(CAST(sourcevalue AS UNSIGNED) = 0 , sourcevalue, CAST(sourcevalue AS UNSIGNED));

/** update priority **/
UPDATE listToRowsTemp
INNER JOIN rel_crosswalkData ON rel_crosswalkData.sourcevalue = listToRowsTemp.matchvalue
SET listToRowsTemp.priority = rel_crosswalkData.targetvalue
WHERE rel_crosswalkData.crosswalkId = cwId;

-- 

-- drop values 
select min(priority) into @minpri from listToRowsTemp;

if (dropValue = 'Y') then
BEGIN
update listToRowsTemp set matchvalue = null where priority is not null and priority <> @minpri;
END;
END If;
if (dropValue = 'N') then
BEGIN
update listToRowsTemp set matchvalue = '' where priority is not null and priority <> @minpri;
END;
END IF;

select group_concat(matchvalue ORDER BY id SEPARATOR ',') into @singleValueFields from listToRowsTemp;
-- update fieldValue

IF (!foroutboundProcessing) then
BEGIN
	set @stmt = concat("update transactiontranslatedIn set ",fieldA," = '",@singleValueFields, "' where transactionInId = ", transactionId,";");
end;
end if;

if (foroutboundProcessing) then
BEGIN
	set @stmt = concat("update transactiontranslatedOut set ",fieldA," = '",@singleValueFields, "' where transactionTargetId = ", transactionId,";");
end;
end if;	
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
drop table listToRowsTemp;

END$$
DELIMITER ;


/** grace 09162014 11:15AM Applied to Test and Live machines **/
use healthelink;

drop procedure if exists ListToRows;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ListToRows`(in fieldA varchar(20), in cwId int /** con1 **/, 
in listOfValues varchar(255), in dropValue  varchar(255) /**con2 - y/n**/, 
in foroutboundProcessing boolean, in transactionId int)
BEGIN

/** create our temp table **/
drop temporary table if exists listToRowsTemp;

CREATE temporary TABLE `listToRowsTemp` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sourceValue` varchar(255) DEFAULT NULL,
  `priority` int DEFAULT NULL,
  `matchValue` varchar(255) DEFAULT NULL,
  `transactionId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
);


	Set @stopVal = 0;
	select LENGTH(listOfValues) - LENGTH(REPLACE(listOfValues, ',', '')) into @stopVal;
	set @stopVal = @stopVal + 2;
	SET @i = 1;

  REPEAT
    INSERT INTO listToRowsTemp (sourcevalue)
      SELECT  trim(strSplit(listOfValues, ',', @i)) from transactionIn limit 1;
    SET @i = @i + 1;
    UNTIL @i = @stopVal
  END REPEAT;

/** make integers **/

update listToRowsTemp set matchvalue = IF(CAST(sourcevalue AS UNSIGNED) = 0 , sourcevalue, CAST(sourcevalue AS UNSIGNED));

/** update priority **/
UPDATE listToRowsTemp
INNER JOIN rel_crosswalkData ON rel_crosswalkData.sourcevalue = listToRowsTemp.matchvalue
SET listToRowsTemp.priority = rel_crosswalkData.targetvalue
WHERE rel_crosswalkData.crosswalkId = cwId;

-- 

-- drop values 
select min(priority) into @minpri from listToRowsTemp;

if (dropValue = 'Y') then
BEGIN
update listToRowsTemp set matchvalue = null where priority is not null and priority <> @minpri;
END;
END If;
if (dropValue = 'N') then
BEGIN
update listToRowsTemp set matchvalue = '' where priority is not null and priority <> @minpri;
END;
END IF;

select group_concat(matchvalue ORDER BY id SEPARATOR ',') into @singleValueFields from listToRowsTemp;
-- update fieldValue

IF (!foroutboundProcessing) then
BEGIN
	set @stmt = concat("update transactiontranslatedIn set ",fieldA," = '",@singleValueFields, "' where transactionInId = ", transactionId,";");
end;
end if;

if (foroutboundProcessing) then
BEGIN
	set @stmt = concat("update transactiontranslatedOut set ",fieldA," = '",@singleValueFields, "' where transactionTargetId = ", transactionId,";");
end;
end if;	
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute
drop temporary table listToRowsTemp;

END$$
DELIMITER ;


/** grace 09192014 03:58 PM applied to live and test db **/

use healthelink; 

drop procedure if exists dropValueByPriorityInboundOnly;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dropValueByPriorityInboundOnly`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255) /** cwid **/, 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
This store procedure takes in values from a field and a cwid
It will loop through the transactions and split the value into a row
The priority for matching value will then be updated
According to con2 - drop value, we will either update the lower priority to null or blank
We will then update field value with new string value
Assuming cw has 59 as priority 1 and 70 as priority 2
59, 07, 12, 71, 22, 70, 02, 44
should become
if drop value is N
59, 07, 12, 71, 22, , 02, 44
if Y
59, 07, 12, 71, 22, 02, 44

sample usage
CALL `healthelink`.`dropValueByPriorityInboundOnly`(94, 623, 'F500', 'F500', '', '10', 'Y', 85, false, 2, 0);
 
**/

/** 
cannot use view as it is not temporary and two runs at the same time will over write each other 
need to insert data to temp table and select from there
**/

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then

proc_batch:begin

drop temporary table macroTopRanked;
CREATE temporary TABLE  `healthelink`.`macroTopRanked` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `fieldVal` LONGTEXT NULL,
  `macroBatchId` int NULL,
  `macrotransactionId` INT NULL,
	`macroConfigId` INT NULL,
  PRIMARY KEY (`id`));


SET @query = CONCAT('insert into macroTopRanked (fieldVal, macroBatchId, macroConfigId, macrotransactionId) 
select ', fieldA, ' , ', batchId, ',' , configId, ', transactionInId from transactiontranslatedIn where transactionInId in 
(select id from transactionIn where configId = ', configId, ' and batchId = ', batchId , ' and statusId not in (', @finalStatusIds,'));'); 

PREPARE stmt from @query; 
EXECUTE stmt; 
DEALLOCATE PREPARE stmt; 


begin

DECLARE cursor_end CONDITION FOR SQLSTATE '02000'; 
DECLARE v_column_val VARCHAR(50); 
DECLARE v_transactionInId VARCHAR(50); 
DECLARE v_batchId VARCHAR(50); 
DECLARE done INT DEFAULT 0; 
DECLARE cur_table CURSOR FOR SELECT fieldVal, macrotransactionId FROM macroTopRanked where macroBatchId = batchId and macroConfigId = configId; 
DECLARE CONTINUE HANDLER FOR cursor_end SET done = 1; 

OPEN cur_table; 
FETCH cur_table INTO v_column_val, v_transactionInId; 
WHILE done = 0 DO 
if (length(v_column_val) > 0) then
	CALL `healthelink`.`ListToRows`(fieldA, con1, v_column_val, con2 , foroutboundProcessing, v_transactionInId);
end if;
FETCH cur_table INTO v_column_val, v_transactionInId; 
END WHILE; 
CLOSE cur_table; 

end;

end proc_batch;
end if;



if (transactionId != 0) then
	set @listValue = "";
	set @stmt  = concat("select ", fieldA, " into @listValue from  ", @translatedTable, " where ",@transactionTable,"Id = ", transactionId, ";" );
	insert into sqlstmt (sqlstmt) values (@stmt);
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute

	-- if length(@listValue) != 0 then
	CALL `healthelink`.`ListToRows`(fieldA, con1, @listValue, con2 , foroutboundProcessing, transactionId);
	-- end if;
END if;


	



-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;


-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;


/** grace 10072014 11:22AM **/

use healthelink;

drop PROCEDURE if exists `dropValueByPriorityInboundOnly`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dropValueByPriorityInboundOnly`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255) /** cwid **/, 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
This store procedure takes in values from a field and a cwid
It will loop through the transactions and split the value into a row
The priority for matching value will then be updated
According to con2 - drop value, we will either update the lower priority to null or blank
We will then update field value with new string value
Assuming cw has 59 as priority 1 and 70 as priority 2
59, 07, 12, 71, 22, 70, 02, 44
should become
if drop value is N
59, 07, 12, 71, 22, , 02, 44
if Y
59, 07, 12, 71, 22, 02, 44

sample usage
CALL `healthelink`.`dropValueByPriorityInboundOnly`(94, 623, 'F500', 'F500', '', '10', 'Y', 85, false, 2, 0);
 
**/

/** 
cannot use view as it is not temporary and two runs at the same time will over write each other 
need to insert data to temp table and select from there
**/

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then

proc_batch:begin

drop temporary table if exists macroTopRanked;

CREATE temporary TABLE  `healthelink`.`macroTopRanked` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `fieldVal` LONGTEXT NULL,
  `macroBatchId` int NULL,
  `macrotransactionId` INT NULL,
	`macroConfigId` INT NULL,
  PRIMARY KEY (`id`));


SET @query = CONCAT('insert into macroTopRanked (fieldVal, macroBatchId, macroConfigId, macrotransactionId) 
select ', fieldA, ' , ', batchId, ',' , configId, ', transactionInId from transactiontranslatedIn where transactionInId in 
(select id from transactionIn where configId = ', configId, ' and batchId = ', batchId , ' and statusId not in (', @finalStatusIds,'));'); 

PREPARE stmt from @query; 
EXECUTE stmt; 
DEALLOCATE PREPARE stmt; 


begin

DECLARE cursor_end CONDITION FOR SQLSTATE '02000'; 
DECLARE v_column_val LONGTEXT; 
DECLARE v_transactionInId VARCHAR(50); 
DECLARE v_batchId VARCHAR(50); 
DECLARE done INT DEFAULT 0; 
DECLARE cur_table CURSOR FOR SELECT fieldVal, macrotransactionId FROM macroTopRanked where macroBatchId = batchId and macroConfigId = configId; 
DECLARE CONTINUE HANDLER FOR cursor_end SET done = 1; 

OPEN cur_table; 
FETCH cur_table INTO v_column_val, v_transactionInId; 
WHILE done = 0 DO 
if (length(v_column_val) > 0) then
	CALL `healthelink`.`ListToRows`(fieldA, con1, v_column_val, con2 , foroutboundProcessing, v_transactionInId);
end if;
FETCH cur_table INTO v_column_val, v_transactionInId; 
END WHILE; 
CLOSE cur_table; 

end;

end proc_batch;
end if;



if (transactionId != 0) then
	set @listValue = "";
	set @stmt  = concat("select ", fieldA, " into @listValue from  ", @translatedTable, " where ",@transactionTable,"Id = ", transactionId, ";" );
	insert into sqlstmt (sqlstmt) values (@stmt);
	PREPARE stmt from @stmt;
	EXECUTE stmt;-- execute

	-- if length(@listValue) != 0 then
	CALL `healthelink`.`ListToRows`(fieldA, con1, @listValue, con2 , foroutboundProcessing, transactionId);
	-- end if;
END if;


	



-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;


-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

/** Chad 10-7-2014 @ 5:44 PM **/

USE `healthelink`;
DROP procedure IF EXISTS `DateToyyyymmdd`;

DELIMITER $$
USE `healthelink`$$

CREATE DEFINER=`root`@`localhost` PROCEDURE `DateToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
This procedure take a string in yyyy-mm-dd hh:mm:ss format and convert it into yyyymmdd. 
"-" can be "/" or "." or character of choice by user
fieldA will be field to conver
fieldB is not in use
con1 is not in use
con2 is not in use
**/

call setInboundOutBoundTables (foroutboundProcessing);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

if (transactionId = 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(", fieldA,", 1, 4), substring(",fieldA,", 6,2), substring(",fieldA,", 9,2))
 where ", @transactionTable ,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,"));");


END if;

if (transactionId != 0) then
set @stmt = concat("update ", @translatedTable," set ",fieldA,
" = concat(substring(", fieldA,", 1, 4), substring(",fieldA,", 6,2), substring(",fieldA,", 9,2)) 
where ", @transactionTable ,"Id = ",transactionId, ";");
END if;


PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- not sure how to pass clear this
END;
END IF;
-- see if we want to return something
SELECT '';

end proc_main$$

DELIMITER ;

INSERT INTO `healthelink`.`macro_names` (`CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `populateFieldA`) VALUES ('1', 'Convert Date to yyyymmdd String', 'DateToyyyymmdd', 'DateToyyyymmdd', 'Please enter field to convert', 1);
