/** 02.11.2014 **/

drop procedure `universaltranslator`.`runMacro`;


/** 02122014 Grace **/

INSERT INTO `universalTranslator`.`lu_ErrorCodes` (`displayText`, `description`, `status`) 
VALUES ('System Error', 'System Error, could be from crosswalks or macros', 1);

DELIMITER $$
CREATE Procedure `universaltranslator`.`setInboundOutBoundTables`(in foroutboundProcessing boolean) 
proc_main:begin

-- this SP sets the inbound / outbound tables
set @translatedTable = "transactionTranslatedIn";
set @transactionTable = "transactionIn";
set @batchTable = "batchUploads";
set @batchIdType = "batchId";
set @errorTable = "transactionInErrors";

if (foroutboundProcessing) THEN
BEGIN -- true
		set @translatedTable = "transactionTranslatedOut";
		set @transactionTable = "transactionTarget";
		set @batchTable = "batchDowloads";
		set @batchIdType = "batchDLId";
		set @errorTable = "transactionOutErrors";
END; 
END IF;

end proc_main$$
DELIMITER ;

/** 02132014 Grace **/
ALTER TABLE `universalTranslator`.`Macro_Names` 
CHANGE COLUMN `Category` `Category` VARCHAR(50) CHARACTER SET 'utf8' NULL DEFAULT 'Stored Procedure' ;

delete from `Macro_Names`;
INSERT INTO `Macro_Names` VALUES (1,'Stored Procedure','MatchFieldAUpdateFieldB','IF SFA = CON1, TFB = CON2',1,NULL,'MatchFieldAUpdateFieldB','','Please enter field number for matching','Please enter field number to update','Please enter the constant to match','Please enter the constant for update');

DELIMITER $$
CREATE Procedure `universaltranslator`.`MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int) 
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId,");");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId,");");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

/** grace 021314 **/
INSERT INTO `universalTranslator`.`macro_names` (`Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`) VALUES ('MatchFAUpdateSF', 'IF SFA = CON1, SF = CON2', 'MatchFAUpdateSF', 'Please enter field number to match', 'Please enter constant to match', 'Please enter constanct to update to');

/** Chad 2.13.14 @ 11:11 AM **/
ALTER TABLE `universalTranslator`.`BatchDownloads` 
ADD COLUMN `lastDownloaded` DATETIME NULL AFTER `mergeable`;

/** Chad 2.13.14 @ 11:09 PM **/
ALTER TABLE `universalTranslator`.`rel_TransportFTPDetails` 
ADD COLUMN `port` VARCHAR(45) NULL AFTER `method`;


/** Chad 2.14.14 @ 11:41 AM **/
CREATE TABLE `universaltranslator`.`targetoutputrunlogs` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `configId` INT NOT NULL,
  `lastRunTime` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`));

/** Chad 2.18.14 @ 11:51 AM **/
ALTER TABLE `universalTranslator`.`message_ToProvider` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_ToOrg` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_PatientAddresses` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL COMMENT 'State - e.g. MA' ;

ALTER TABLE `universalTranslator`.`message_FromProvider` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`message_FromOrg` 
CHANGE COLUMN `state` `state` VARCHAR(45) NULL DEFAULT NULL ;


/** 02.18.2014 **/
ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `required` BIT NULL AFTER `configurationFormFieldsId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `required` BIT NULL AFTER `configurationFormFieldsId`;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `stackTrace` TEXT NULL AFTER `validationTypeId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `stackTrace` TEXT NULL AFTER `validationTypeId`;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `transactionInId` `transactionInId` INT(11) NULL ;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
CHANGE COLUMN `transactionTargetId` `transactionInId` INT(11) NULL ;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD COLUMN `configId` INT NULL AFTER `batchUploadId`;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
CHANGE COLUMN `transactionInId` `transactionTargetId` INT(11) NULL DEFAULT NULL ;

ALTER TABLE `universalTranslator`.`transactionOutErrors` 
ADD COLUMN `configId` INT NULL AFTER `transactionTargetId`;

/** 02.19.14 Grace **/
ALTER TABLE `universalTranslator`.`transactionInErrors` 
DROP FOREIGN KEY `configFFFKId`;
ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `configurationFormFieldsId` `configurationFormFieldsId` INT(11) NULL ;
ALTER TABLE `universalTranslator`.`transactionInErrors` 
ADD CONSTRAINT `configFFFKId`
  FOREIGN KEY (`configurationFormFieldsId`)
  REFERENCES `universalTranslator`.`configurationFormFields` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

ALTER TABLE `universalTranslator`.`transactionInErrors` 
CHANGE COLUMN `dateCreated` `dateCreated` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ;


/** Grace 02.19.14 **/
ALTER TABLE `universalTranslator`.`rel_crosswalkData` 
CHANGE COLUMN `targetValue` `targetValue` VARCHAR(45) NOT NULL ;


/** Chad 2.20.14 @ 11:26 AM **/
CREATE TABLE `universalTranslator`.`configurationHL7Details` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `configId` INT NOT NULL,
  `fieldSeparator` VARCHAR(1) NOT NULL DEFAULT '|',
  `componentSeparator` VARCHAR(1) NOT NULL DEFAULT '^',
  `EscapeChar` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `hl7ConfigIdfk_idx` (`configId` ASC),
  CONSTRAINT `hl7ConfigIdfk`
    FOREIGN KEY (`configId`)
    REFERENCES `universalTranslator`.`configurations` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

CREATE TABLE `universalTranslator`.`configurationHL7Segments` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `hl7Id` INT NOT NULL,
  `segmentName` VARCHAR(3) NOT NULL,
  `displayPos` INT NOT NULL DEFAULT 1,
  PRIMARY KEY (`id`));

ALTER TABLE `universalTranslator`.`configurationHL7Segments` 
ADD INDEX `segHL7Idfk_idx` (`hl7Id` ASC);
ALTER TABLE `universalTranslator`.`configurationHL7Segments` 
ADD CONSTRAINT `segHL7Idfk`
  FOREIGN KEY (`hl7Id`)
  REFERENCES `universalTranslator`.`configurationHL7Details` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

CREATE TABLE `universalTranslator`.`configurationHL7Elements` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `hl7Id` INT NOT NULL,
  `segmentId` INT NOT NULL,
  `elementName` VARCHAR(255) NOT NULL,
  `defaultValue` VARCHAR(45) NULL DEFAULT 'null',
  `fieldDescriptor` VARCHAR(255) NULL,
  `fieldValue` VARCHAR(4) NULL DEFAULT 'null',
  `displayPos` INT NOT NULL DEFAULT 1,
  PRIMARY KEY (`id`));

ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD INDEX `elemHLyIdfk_idx` (`hl7Id` ASC),
ADD INDEX `elemSegIdfk_idx` (`segmentId` ASC);
ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD CONSTRAINT `elemHLyIdfk`
  FOREIGN KEY (`hl7Id`)
  REFERENCES `universalTranslator`.`configurationHL7Details` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION,
ADD CONSTRAINT `elemSegIdfk`
  FOREIGN KEY (`segmentId`)
  REFERENCES `universalTranslator`.`configurationHL7Segments` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;


/** Chad 2.21.14 @ 3:13 PM **/
ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
DROP COLUMN `fieldValue`,
DROP COLUMN `fieldDescriptor`,
DROP COLUMN `defaultValue`;

CREATE TABLE `universalTranslator`.`configurationHL7ElementValues` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `elementId` INT NOT NULL,
  `defaultValue` VARCHAR(45) NULL DEFAULT NULL,
  `fieldDescriptor` VARCHAR(255) NULL DEFAULT NULL,
  `fieldValue` VARCHAR(4) NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `elemValIdfk_idx` (`elementId` ASC),
  CONSTRAINT `elemValIdfk`
    FOREIGN KEY (`elementId`)
    REFERENCES `universalTranslator`.`configurationHL7Elements` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

ALTER TABLE `universalTranslator`.`configurationHL7ElementValues` 
ADD COLUMN `displayPos` INT NULL DEFAULT 1 AFTER `fieldValue`;

ALTER TABLE `universalTranslator`.`configurationHL7ElementValues` 
DROP COLUMN `defaultValue`;

ALTER TABLE `universalTranslator`.`configurationHL7Elements` 
ADD COLUMN `defaultValue` VARCHAR(45) NULL AFTER `displayPos`;

  
  /** grace 022114 **/
  drop procedure insertValidationErrors;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in cffId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[a-z0-9\._%+!$&*=^|~#%\'`?{}/\-]+@[a-z0-9\.-]+\.[a-z]{2,6}$ or ^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, cffId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;
 
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, configurationFormFieldsId, errorid, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',cffId,',2, ', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId != 12);');

PREPARE stmt from @stmt;
EXECUTE stmt;

 END$$
DELIMITER ;


drop procedure MatchFieldAUpdateFieldB;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFieldAUpdateFieldB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",fieldB," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int)
proc_main:begin

-- this SP matches FieldA with Con1 and then updates fieldB with Con2
-- this sets out table
call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

-- build our sql
set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where ",fieldA," = '",con1,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
set @stmt = concat("update ",@translatedTable, " set ",srcField," = null where ",fieldB," != '",con2,"'
and ",@transactionTable,"Id in (select id from ",@transactionTable,
" where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId != 12);");
PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$
DELIMITER ;

/** grace 02242014 **/
drop procedure insertValidationErrors;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in cffId int)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `universalTranslator`.`stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, cffId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 5 THEN set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
    ELSE
        BEGIN
        END;
	END 
	CASE;
 
set @stmt = concat(
'insert into transactionInerrors (batchUploadId, transactionInId, configurationFormFieldsId, errorid, 
validationTypeId) SELECT ', batchUploadId, ', transactionInId, ',cffId,',2, ', vtType,'  
 FROM transactionTranslatedIn WHERE F' ,fieldNo, ' not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and configId = ', configId, ' and transactionInId 
in (select id from transactionIn where batchId = ', batchUploadId,' and configId = ', configId,' and statusId != 12);');

PREPARE stmt from @stmt;
EXECUTE stmt;

 END$$
DELIMITER ;

/** 02242014 Grace **/
ALTER TABLE `universalTranslator`.`transactionIn` 
ADD COLUMN `loadTableId` VARCHAR(45) NULL AFTER `transactionTargetId`;

ALTER TABLE `universalTranslator`.`transactionInRecords` 
ADD COLUMN `loadTableId` VARCHAR(45) NULL AFTER `dateCreated`;

/** 02252014 Grace **/
CREATE TABLE `universalTranslator`.`batchUploadConfirgurations` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `batchId` INT NOT NULL,
  `configId` INT NULL,
  `dateCreated` DATETIME NOT NULL DEFAULT current_timestamp,
  PRIMARY KEY (`id`));

