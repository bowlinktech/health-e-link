/** 11012018 **/
INSERT INTO `healthelink`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('149', '1', 'ReplaceFAWithStringValueFromList', 'ReplaceFAWithStringValueFromList', 'ReplaceFAWithStringValueFromList', 'Please enter field to update', 'Please enter the delimiter for the string', 'Please enter location of string to extract', TRUE);

USE `healthelink`;
DROP procedure IF EXISTS `ReplaceFAWithStringValueFromList`;

DELIMITER $$
USE `healthelink`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ReplaceFAWithStringValueFromList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

-- if the length of the fieldA is great than or equal to con1, we replace with con2

-- build our sql
if (transactionId = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = strsplit (",srcField,", '",con1,"',",con2,")    ", 
    " where (length(",srcField, ") > 0 and ", srcField ," is not null) and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	END if;


if (transactionId != 0) then
	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = strsplit (",srcField,", '",con1,"',",con2,")    ", 
     "  where (length (", srcField ,  ") >  0 and ", srcField, " is not null) and ",
	@transactionTable,"Id = ", transactionId,";");
	END if;

PREPARE stmt from @stmt;
EXECUTE stmt;-- execute
DEALLOCATE PREPARE stmt;

-- we check pass /clear
if (passClear = 2) THEN
BEGIN
-- accessible
END;
END IF;

-- the only error for this is if SP bombs, no need to write in insert error logs
select '';
end proc_main$$

DELIMITER ;

